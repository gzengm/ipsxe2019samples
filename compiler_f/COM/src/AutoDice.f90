!#==============================================================================
!#
!#  SAMPLE SOURCE CODE - SUBJECT TO THE TERMS OF SAMPLE CODE LICENSE AGREEMENT,
!#  http://software.intel.com/en-us/articles/intel-sample-source-code-license-agreement/
!#
!#  Copyright 2007-2016 Intel Corporation
!#
!#  THIS FILE IS PROVIDED "AS IS" WITH NO WARRANTIES, EXPRESS OR IMPLIED,
!#  INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTY OF MERCHANTABILITY,
!#  FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT OF INTELLECTUAL
!#  PROPERTY RIGHTS.
!#
!#==============================================================================
!#
!#
!#******************************************************************************
!# Content:
!#       AutoDice sample program for Intel Visual Fortran
!#******************************************************************************
! This sample program simulates rolling two dice and then uses Windows
! Automation to tell Microsoft Excel* to draw a histogram of the numbers.
! The EXCEL module generated by the Fortran Module Wizard
! is used as the interface to Excel.  The  following Excel interfaces were
! selected:
!     _Application, _Chart, _Workbook, _Worksheet, Axes, Charts, Range,
!     Workbooks
!
! NOTE: 
!         After running this sample, if you save the changes to HISTO.XLS,
!         you must re-copy the original version from the Visual Fortran 
!         installation for this sample to work correctly.
!
! You must have Microsoft Excel* 2016, 2013, 2010, or 2007 installed in 
! order to run this sample
!
! * Other names and brands may be claimed as the property of others


    PROGRAM ExcelSample

	  USE IFCOM
	  USE IFCOMTY
	  USE IFAUTO
	  USE IFPORT, ONLY: GETCWD, SLEEPQQ
	  USE ADOBJECTS
	  USE EXCEL
      USE ISO_FORTRAN_ENV, ONLY: INT32,REAL32
      IMPLICIT NONE                       
	
	! Variables
	  INTEGER(INT32) status
	  INTEGER(INT32) loopCount
	  INTEGER(INT32) die1
	  INTEGER(INT32) die2
	  INTEGER(INT32) roll
	  INTEGER(INT32) maxScale
	  CHARACTER (LEN = 32) :: loopc
	  INTEGER   i
      REAL(REAL32)    rnd
	  INTEGER(INT32), DIMENSION(1:12) :: cellCounts
	  CHARACTER(255) curdir
	  CHARACTER(2) office_version_string

	! Variant arguments
	  TYPE (VARIANT) :: vBSTR1
	  TYPE (VARIANT) :: vBSTR2
	  TYPE (VARIANT) :: vBSTR3
	  TYPE (VARIANT) :: vInt
	  TYPE (VARIANT) :: vRange
      
    ! Get arguments

	! Initialize object pointers
	  CALL INITOBJECTS()

	! Create an Excel object.  Try Office 2016 (16), 2013 (15),  2010 (14 and 13), then 2007 (12).
	  CALL COMINITIALIZE(status)
	  DO I=16,12,-1
	    WRITE (office_version_string, '(I2)') I
        CALL COMCREATEOBJECT ("Excel.Application."//office_version_string, excelapp, status)
        if (excelapp /= 0) exit ! If successful, exit the loop
        END DO
        
 	  IF (excelapp == 0) THEN
		  WRITE (*, '(" Unable to create Excel object; Aborting")')
		  STOP
	  END IF
      CALL $Application_SetVisible(excelapp, .TRUE.)

	! Here is a sketch of the code below in pseudocode...
	!
	!	workbooks = excelapp.GetWorkbooks()
	!	workbook = workbooks.Open(spreadsheet)
	!	worksheet = workbook.GetActiveSheet
	!	range = worksheet.GetRange("A1", "L1")
	!	range.Select()
	!	charts = workbook.GetCharts()
	!	chart = charts.Add()
	!	chart.ChartWizard(gallery=chartType, title=title, categoryTitle=title, valueTitle=title)
	!	valueAxis = chart.Axes(type=xlValue, axisGroup=xlPrimary)
	!   valueAxis.MaximumScale(loopcount/5)

	! Get the WORKBOOKS object
	  workbooks = $Application_GetWorkbooks(excelapp, $STATUS = status)
	  CALL Check_Status(status, " Unable to get WORKBOOKS object", workbooks)

	! Open the spreadsheet file, assumed to be in the current directory
	i = GETCWD(curdir)
	  workbook = Workbooks_Open(workbooks, &
       trim(curdir)//"\HISTO.XLS", &
        $STATUS = status)
	  CALL Check_Status(status, " Unable to get WORKBOOK object; ensure that the file path is correct", workbook)

	! Get the worksheet
	  vInt%VT = VT_I4
	  vInt%VU%LONG_VAL = 1
      worksheet = $Workbook_GetActiveSheet(workbook, status)
	  CALL Check_Status(status, " Unable to get WORKSHEET object", worksheet)

	! Initialize the cell counts
	  DO i=1,12
		  range = 0
		  cells(i) = range
		  cellCounts(i) = 0
	  END DO

	! Create a new chart
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_BSTR
	  bstr1 = ConvertStringToBSTR("A1")
	  vBSTR1%VU%PTR_VAL = bstr1
	  CALL VariantInit(vBSTR2)
	  vBSTR2%VT = VT_BSTR
	  bstr2 = ConvertStringToBSTR("L1")
	  vBSTR2%VU%PTR_VAL = bstr2
	  range = $Worksheet_GetRange(worksheet, vBSTR1, vBSTR2, status)
	  CALL Check_Status(status, " Unable to get RANGE object", range)
	  status = VariantClear(vBSTR1)
	  bstr1 = 0
	  status = VariantClear(vBSTR2)
	  bstr2 = 0

	  status = AUTOSETPROPERTY (range, "VALUE", cellCounts)
	  vRange = Range_Select(range, status)
	  charts = $Workbook_GetCharts(workbook, $STATUS = status)
	  CALL Check_Status(status, " Unable to get CHARTS object", charts)
	  chart = Charts_Add(charts, $STATUS = status)
	  CALL Check_Status(status, " Unable to add CHART object", chart)

	! Invoke the ChartWizard to format the chart
	!	chart.ChartWizard(gallery=chartType, title=title, categoryTitle=title, valueTitle=title)
	  CALL VariantInit(vInt)
	  vInt%VT = VT_I4
	  vInt%VU%LONG_VAL = 11
	  CALL VariantInit(vBSTR1)
	  vBSTR1%VT = VT_BSTR
	  bstr1 = ConvertStringToBSTR("Dice Histogram")
	  vBSTR1%VU%PTR_VAL = bstr1
	  CALL VariantInit(vBSTR2)
	  vBSTR2%VT = VT_BSTR
	  bstr2 = ConvertStringToBSTR("Roll")
	  vBSTR2%VU%PTR_VAL = bstr2
	  CALL VariantInit(vBSTR3)
	  vBSTR3%VT = VT_BSTR
	  bstr3 = ConvertStringToBSTR("Times")
	  vBSTR3%VU%PTR_VAL = bstr3
 	  CALL $Chart_ChartWizard(chart, &
			Gallery = vInt, &
			Title = vBSTR1, &
			CategoryTitle = vBSTR2, &
			ValueTitle = vBSTR3, &
			$STATUS = status)
	  CALL Check_Status(status, " Unable to invoke ChartWizard")
	  status = VariantClear(vBSTR1)
	  bstr1 = 0
	  status = VariantClear(vBSTR2)
	  bstr2 = 0
	  status = VariantClear(vBSTR3)
	  bstr3 = 0

	! Determine the number of times to roll the dice
	  IF (COMMAND_ARGUMENT_COUNT() > 1) THEN
		  CALL GET_COMMAND_ARGUMENT(1, loopc)
		  READ(loopc, *) loopcount
	  ELSE
		  loopcount = 1000;
	  END IF

	! Set some chart properties
	  CALL VariantInit(vInt)
	  vInt%VT = VT_I4
	  vInt%VU%LONG_VAL = xlValue
	  valueAxis = $Chart_Axes(chart, vInt, xlPrimary, $STATUS = status)
	  CALL Check_Status(status, " Unable to get AXIS object", valueAxis)

	  maxScale = loopcount/5
	  status = AUTOSETPROPERTY (valueAxis, "MaximumScale", maxScale)
	  CALL Check_Status(status, " Unable to set AXIS MaximumScale")

	! Loop the specified number of times 
	  CALL RANDOM_SEED
	  DO i=1,loopcount
		  CALL RANDOM_NUMBER(rnd)
		  die1 = NINT((rnd * 6) + 0.5)
		  CALL RANDOM_NUMBER(rnd)
		  die2 = NINT((rnd * 6) + 0.5)
		  roll = die1 + die2
		  cellCounts(roll) = cellCounts(roll) + 1
		  IF (MOD(i, 200) == 0) THEN
			  status = AUTOSETPROPERTY (range, "VALUE", cellCounts)
			  CALL Check_Status(status, " Unable to set RANGE value")
		  END IF
	  END DO

	! Release all objects
	  CALL RELEASEOBJECTS()
	  CALL COMUNINITIALIZE()
      
    CONTAINS
    
    SUBROUTINE Check_Status(olestatus, errorMsg, object)
      IMPLICIT NONE                       

	  INTEGER(INT32), INTENT(IN) :: olestatus
	  CHARACTER (LEN = *), INTENT(IN) :: errorMsg
      INTEGER(INT_PTR_KIND()), INTENT(INOUT), OPTIONAL :: object

	  IF (olestatus >= 0) THEN
		  RETURN
      END IF

	! Error handling code
    ! If the status is negative the previous COM call may have returned
    ! garbage for the object ID, so zero it
      if (PRESENT(object)) object = 0
	  CALL RELEASEOBJECTS()
	  WRITE (*, '(A, "; OLE error status = 0x", Z8.8, "; Aborting")') TRIM(errorMsg), olestatus
	  CALL SLEEPQQ(5000)
	  STOP -1

    END SUBROUTINE Check_Status


    END PROGRAM ExcelSample


